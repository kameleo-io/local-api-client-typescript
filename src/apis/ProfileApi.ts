/* tslint:disable */
/* eslint-disable */
/**
 * kameleo-local-api
 * You can use the following API endpoints to communicate with the local running Kameleo programmatically.
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
    BrowserSettings,
    CreateProfileRequest,
    ExportProfileRequest,
    ImportProfileRequest,
    ProblemResponse,
    ProfilePreview,
    ProfileResponse,
    StatusResponse,
    UpdateProfileRequest,
} from "../models/index";
import {
    BrowserSettingsFromJSON,
    BrowserSettingsToJSON,
    CreateProfileRequestFromJSON,
    CreateProfileRequestToJSON,
    ExportProfileRequestFromJSON,
    ExportProfileRequestToJSON,
    ImportProfileRequestFromJSON,
    ImportProfileRequestToJSON,
    ProblemResponseFromJSON,
    ProblemResponseToJSON,
    ProfilePreviewFromJSON,
    ProfilePreviewToJSON,
    ProfileResponseFromJSON,
    ProfileResponseToJSON,
    StatusResponseFromJSON,
    StatusResponseToJSON,
    UpdateProfileRequestFromJSON,
    UpdateProfileRequestToJSON,
} from "../models/index";

export interface CreateProfileOperationRequest {
    createProfileRequest: CreateProfileRequest;
}

export interface DeleteProfileRequest {
    profileId: string;
}

export interface DuplicateProfileRequest {
    profileId: string;
}

export interface ExportProfileOperationRequest {
    profileId: string;
    exportProfileRequest: ExportProfileRequest;
}

export interface GetProfileStatusRequest {
    profileId: string;
}

export interface ImportProfileOperationRequest {
    importProfileRequest?: ImportProfileRequest;
}

export interface ReadProfileRequest {
    profileId: string;
}

export interface StartProfileRequest {
    profileId: string;
    browserSettings?: BrowserSettings;
}

export interface StopProfileRequest {
    profileId: string;
}

export interface UpdateProfileOperationRequest {
    profileId: string;
    updateProfileRequest: UpdateProfileRequest;
}

export interface UpgradeProfileKernelRequest {
    profileId: string;
}

/**
 *
 */
export class ProfileApi extends runtime.BaseAPI {
    /**
     * Create a new profile based on a selected fingerprint. Supply the required configuration in the request body, then receive the newly  created profile’s full details.
     */
    async createProfileRaw(
        requestParameters: CreateProfileOperationRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ProfileResponse>> {
        if (requestParameters["createProfileRequest"] == null) {
            throw new runtime.RequiredError(
                "createProfileRequest",
                'Required parameter "createProfileRequest" was null or undefined when calling createProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        const response = await this.request(
            {
                path: `/profiles/new`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: CreateProfileRequestToJSON(requestParameters["createProfileRequest"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ProfileResponseFromJSON(jsonValue));
    }

    /**
     * Create a new profile based on a selected fingerprint. Supply the required configuration in the request body, then receive the newly  created profile’s full details.
     */
    async createProfile(
        createProfileRequest: CreateProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ProfileResponse> {
        const response = await this.createProfileRaw({ createProfileRequest: createProfileRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Permanently delete a profile from your workspace.
     */
    async deleteProfileRaw(
        requestParameters: DeleteProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling deleteProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/profiles/{profileId}`.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters["profileId"]))),
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Permanently delete a profile from your workspace.
     */
    async deleteProfile(profileId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProfileRaw({ profileId: profileId }, initOverrides);
    }

    /**
     * Duplicate an existing profile by creating an exact copy with a new unique identifier. Use this endpoint to clone a profile while preserving  all its configuration details and data.
     */
    async duplicateProfileRaw(
        requestParameters: DuplicateProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ProfileResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling duplicateProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/profiles/{profileId}/duplicate`.replace(
                    `{${"profileId"}}`,
                    encodeURIComponent(String(requestParameters["profileId"])),
                ),
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ProfileResponseFromJSON(jsonValue));
    }

    /**
     * Duplicate an existing profile by creating an exact copy with a new unique identifier. Use this endpoint to clone a profile while preserving  all its configuration details and data.
     */
    async duplicateProfile(profileId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProfileResponse> {
        const response = await this.duplicateProfileRaw({ profileId: profileId }, initOverrides);
        return await response.value();
    }

    /**
     * Export a profile to a .kameleo file by providing the target file path in the request body. Use this to back up all profile attributes —  including settings, browsing data, cookies, history, bookmarks, and extensions — for later restoration or migration.
     */
    async exportProfileRaw(
        requestParameters: ExportProfileOperationRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ProfileResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling exportProfile().',
            );
        }

        if (requestParameters["exportProfileRequest"] == null) {
            throw new runtime.RequiredError(
                "exportProfileRequest",
                'Required parameter "exportProfileRequest" was null or undefined when calling exportProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        const response = await this.request(
            {
                path: `/profiles/{profileId}/export`.replace(
                    `{${"profileId"}}`,
                    encodeURIComponent(String(requestParameters["profileId"])),
                ),
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ExportProfileRequestToJSON(requestParameters["exportProfileRequest"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ProfileResponseFromJSON(jsonValue));
    }

    /**
     * Export a profile to a .kameleo file by providing the target file path in the request body. Use this to back up all profile attributes —  including settings, browsing data, cookies, history, bookmarks, and extensions — for later restoration or migration.
     */
    async exportProfile(
        profileId: string,
        exportProfileRequest: ExportProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ProfileResponse> {
        const response = await this.exportProfileRaw({ profileId: profileId, exportProfileRequest: exportProfileRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Check the current status of a profile, including its lifecycle and persistence states.
     */
    async getProfileStatusRaw(
        requestParameters: GetProfileStatusRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<StatusResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling getProfileStatus().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/profiles/{profileId}/status`.replace(
                    `{${"profileId"}}`,
                    encodeURIComponent(String(requestParameters["profileId"])),
                ),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusResponseFromJSON(jsonValue));
    }

    /**
     * Check the current status of a profile, including its lifecycle and persistence states.
     */
    async getProfileStatus(profileId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatusResponse> {
        const response = await this.getProfileStatusRaw({ profileId: profileId }, initOverrides);
        return await response.value();
    }

    /**
     * Imports a profile from a .kameleo file, effectively recreating the profile with all its attributes, including settings, browsing data,  cookies, history, bookmarks, and any installed extensions/addons. If the profile is already loaded, the import process will fail.
     */
    async importProfileRaw(
        requestParameters: ImportProfileOperationRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ProfileResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        const response = await this.request(
            {
                path: `/profiles/import`,
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: ImportProfileRequestToJSON(requestParameters["importProfileRequest"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ProfileResponseFromJSON(jsonValue));
    }

    /**
     * Imports a profile from a .kameleo file, effectively recreating the profile with all its attributes, including settings, browsing data,  cookies, history, bookmarks, and any installed extensions/addons. If the profile is already loaded, the import process will fail.
     */
    async importProfile(
        importProfileRequest?: ImportProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ProfileResponse> {
        const response = await this.importProfileRaw({ importProfileRequest: importProfileRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of all profiles loaded in your workspace. Use this endpoint to view a preview of each profile so you can quickly assess  available profiles.
     */
    async listProfilesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProfilePreview>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/profiles`,
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProfilePreviewFromJSON));
    }

    /**
     * Retrieve a list of all profiles loaded in your workspace. Use this endpoint to view a preview of each profile so you can quickly assess  available profiles.
     */
    async listProfiles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProfilePreview>> {
        const response = await this.listProfilesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the profile with the specified GUID from the current workspace. On startup, Kameleo will automatically scan and load profiles stored  in your workspace folder on startup.
     */
    async readProfileRaw(
        requestParameters: ReadProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ProfileResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling readProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/profiles/{profileId}`.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters["profileId"]))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ProfileResponseFromJSON(jsonValue));
    }

    /**
     * Gets the profile with the specified GUID from the current workspace. On startup, Kameleo will automatically scan and load profiles stored  in your workspace folder on startup.
     */
    async readProfile(profileId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProfileResponse> {
        const response = await this.readProfileRaw({ profileId: profileId }, initOverrides);
        return await response.value();
    }

    /**
     * Starts the selected profile by transitioning its status to \'starting\', launching the kernel (Chroma or Junglefox) associated with the  profile, and then changing its status to \'running\'.  If there is an error during start-up, it will be \'terminated\'. Note that the required kernel might not be available locally, so it may be  downloaded during the profile start.  Optional command line arguments or settings can be passed to the browser engines.
     */
    async startProfileRaw(
        requestParameters: StartProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<StatusResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling startProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        const response = await this.request(
            {
                path: `/profiles/{profileId}/start`.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters["profileId"]))),
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: BrowserSettingsToJSON(requestParameters["browserSettings"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusResponseFromJSON(jsonValue));
    }

    /**
     * Starts the selected profile by transitioning its status to \'starting\', launching the kernel (Chroma or Junglefox) associated with the  profile, and then changing its status to \'running\'.  If there is an error during start-up, it will be \'terminated\'. Note that the required kernel might not be available locally, so it may be  downloaded during the profile start.  Optional command line arguments or settings can be passed to the browser engines.
     */
    async startProfile(
        profileId: string,
        browserSettings?: BrowserSettings,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<StatusResponse> {
        const response = await this.startProfileRaw({ profileId: profileId, browserSettings: browserSettings }, initOverrides);
        return await response.value();
    }

    /**
     * Stop a running profile by gracefully shutting down its browser engine and releasing allocated resources. Use this endpoint to transition  the profile from \'running\' to \'terminated\' state.
     */
    async stopProfileRaw(
        requestParameters: StopProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<StatusResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling stopProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/profiles/{profileId}/stop`.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters["profileId"]))),
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusResponseFromJSON(jsonValue));
    }

    /**
     * Stop a running profile by gracefully shutting down its browser engine and releasing allocated resources. Use this endpoint to transition  the profile from \'running\' to \'terminated\' state.
     */
    async stopProfile(profileId: string, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatusResponse> {
        const response = await this.stopProfileRaw({ profileId: profileId }, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing profile’s settings by providing the new configuration options in the request body. Use this to modify aspects like  spoofing options or proxy settings, then receive the updated profile details.
     */
    async updateProfileRaw(
        requestParameters: UpdateProfileOperationRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ProfileResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling updateProfile().',
            );
        }

        if (requestParameters["updateProfileRequest"] == null) {
            throw new runtime.RequiredError(
                "updateProfileRequest",
                'Required parameter "updateProfileRequest" was null or undefined when calling updateProfile().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters["Content-Type"] = "application/json";

        const response = await this.request(
            {
                path: `/profiles/{profileId}`.replace(`{${"profileId"}}`, encodeURIComponent(String(requestParameters["profileId"]))),
                method: "PUT",
                headers: headerParameters,
                query: queryParameters,
                body: UpdateProfileRequestToJSON(requestParameters["updateProfileRequest"]),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ProfileResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing profile’s settings by providing the new configuration options in the request body. Use this to modify aspects like  spoofing options or proxy settings, then receive the updated profile details.
     */
    async updateProfile(
        profileId: string,
        updateProfileRequest: UpdateProfileRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ProfileResponse> {
        const response = await this.updateProfileRaw({ profileId: profileId, updateProfileRequest: updateProfileRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Upgrades the profile\'s fingerprint to the most recent browser version available from the server.  This also updates the profile\'s corresponding kernel if there\'s a better match available for the new fingerprint.  The new fingerprint is tailored to the profile\'s current device, browser and operating system. Note that upgrading a profile\'s kernel will alter its browser fingerprint.
     */
    async upgradeProfileKernelRaw(
        requestParameters: UpgradeProfileKernelRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<ProfileResponse>> {
        if (requestParameters["profileId"] == null) {
            throw new runtime.RequiredError(
                "profileId",
                'Required parameter "profileId" was null or undefined when calling upgradeProfileKernel().',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request(
            {
                path: `/profiles/{profileId}/upgrade`.replace(
                    `{${"profileId"}}`,
                    encodeURIComponent(String(requestParameters["profileId"])),
                ),
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => ProfileResponseFromJSON(jsonValue));
    }

    /**
     * Upgrades the profile\'s fingerprint to the most recent browser version available from the server.  This also updates the profile\'s corresponding kernel if there\'s a better match available for the new fingerprint.  The new fingerprint is tailored to the profile\'s current device, browser and operating system. Note that upgrading a profile\'s kernel will alter its browser fingerprint.
     */
    async upgradeProfileKernel(
        profileId: string,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<ProfileResponse | null | undefined> {
        const response = await this.upgradeProfileKernelRaw({ profileId: profileId }, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }
}
